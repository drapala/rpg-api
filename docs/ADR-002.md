# ADR-002: Battle Engine Design (Strategy + Factory + Template Method)

## Status
Accepted

## Context
The battle (F4) requires different formulas and behaviors depending on the character's job (Warrior, Thief, Mage).  
We also need a flexible way to determine attack order, execute rounds, and extend rules later (e.g., new jobs, items, party battles).  
A naive implementation (large `if/else` or `switch`) would work for now, but it would violate SOLID and make the code hard to extend.

## Decision
We will implement the battle system using **Strategy, Factory, and Template Method**:
- **Strategy Pattern**: Encapsulate job-specific formulas for Attack/Speed.
- **Factory Pattern**: Centralize creation of characters with correct stats and calculators.
- **Template Method**: Define the battle flow (rounds, turns, victory condition) while allowing customization of steps.

## Alternatives Considered
- **Hardcoded if/else**: Simple, but not extensible; adding new jobs would require modifying core logic.
- **Single BattleService** with mixed logic: Easier initially, but violates separation of concerns.
- **Polymorphic methods in Character class**: Possible, but mixes domain state with too much behavior, reducing clarity.

## Consequences
- ✅ Extensible for new jobs and mechanics without changing existing code.
- ✅ Clear separation of responsibilities (battle flow vs. job formulas).
- ✅ Easier to test in isolation (unit tests per strategy).
- ⚠️ Slightly more boilerplate and abstractions than a naive implementation.
- ⚠️ Over-engineering risk for such a small assignment, but justified to demonstrate clean design.

## Notes
This ADR complements ADR-001: while ADR-001 justifies technology choice (Spring Boot), ADR-002 documents a core **domain design decision** for the battle engine.
